[
  {
    "ruleId": "",
    "ruleTitle": "Connection Lifecycle Management",
    "type": "bad",
    "code": "// No connection state handling - using old API\nimport { DbConnection } from './generated';\n\n// Just connect and hope for the best\nconst conn = DbConnection.builder()\n  .withUri('ws://localhost:3000')\n  .withModuleName('my-module')\n  .build();\n\n// No handling of disconnects or errors\n// User has no idea if they're connected or not",
    "language": "typescript",
    "description": "ignoring connection events"
  },
  {
    "ruleId": "",
    "ruleTitle": "Connection Lifecycle Management",
    "type": "good",
    "code": "// React hook for connection state\nimport { useState, useEffect, useRef } from 'react';\nimport { GameClient, ConnectionState } from './GameClient';\n\nfunction useConnectionState() {\n  const [state, setState] = useState<ConnectionState>('disconnected');\n  const clientRef = useRef<GameClient | null>(null);\n\n  useEffect(() => {\n    clientRef.current = new GameClient(setState);\n    clientRef.current.connect();\n\n    return () => {\n      clientRef.current?.disconnect();\n    };\n  }, []);\n\n  return { state, client: clientRef.current };\n}\n\n// Connection status indicator component\nfunction ConnectionStatus() {\n  const { state } = useConnectionState();\n\n  const statusMap = {\n    disconnected: { color: 'red', text: 'Offline' },\n    connecting: { color: 'yellow', text: 'Connecting...' },\n    connected: { color: 'green', text: 'Connected' },\n    reconnecting: { color: 'orange', text: 'Reconnecting...' }\n  };\n\n  const status = statusMap[state];\n\n  return (\n    <div style={{ color: status.color }}>\n      {status.text}\n    </div>\n  );\n}\n\nexport { useConnectionState, ConnectionStatus };",
    "language": "typescript",
    "description": "comprehensive connection lifecycle"
  },
  {
    "ruleId": "",
    "ruleTitle": "Error Handling in Modules",
    "type": "bad",
    "code": "import { spacetimedb, table, t, ReducerContext } from 'spacetimedb';\n\nspacetimedb.reducer(\n  'purchase_item',\n  { itemId: t.string(), quantity: t.u32() },\n  (ctx: ReducerContext, { itemId, quantity }) => {\n    const user = ctx.db.user.identity.find(ctx.sender);\n    const item = ctx.db.item.id.find(itemId);\n\n    // Silent failure - no error if user or item doesn't exist\n    if (!user || !item) {\n      return; // Client has no idea what went wrong\n    }\n\n    // No validation - can go negative\n    ctx.db.user.identity.update({ ...user, balance: user.balance - item.price * BigInt(quantity) });\n\n    // Silent failure if insufficient stock\n    if (item.stock < quantity) {\n      return; // Purchase \"succeeded\" but nothing happened\n    }\n\n    ctx.db.item.id.update({ ...item, stock: item.stock - quantity });\n  }\n);",
    "language": "typescript",
    "description": "poor error handling"
  },
  {
    "ruleId": "",
    "ruleTitle": "Error Handling in Modules",
    "type": "good",
    "code": "// Client-side error handling\nimport { DbConnection } from './generated';\n\nasync function handlePurchase(conn: DbConnection, itemId: string, quantity: number) {\n  try {\n    await conn.reducers.purchaseItem(itemId, quantity);\n    showToast('Purchase successful!', 'success');\n  } catch (error) {\n    if (error instanceof Error) {\n      // Handle specific error types\n      if (error.message.includes('Insufficient balance')) {\n        showToast('Not enough coins! Earn more or buy coins.', 'warning');\n        showBuyCoinsModal();\n      } else if (error.message.includes('Insufficient stock')) {\n        showToast('Item out of stock. Try again later.', 'error');\n      } else if (error.message.includes('not found')) {\n        showToast('Item no longer available.', 'error');\n        refreshInventory();\n      } else {\n        // Generic error\n        showToast(`Purchase failed: ${error.message}`, 'error');\n      }\n    } else {\n      showToast('An unexpected error occurred.', 'error');\n    }\n\n    console.error('Purchase error:', error);\n  }\n}",
    "language": "typescript",
    "description": "comprehensive error handling"
  },
  {
    "ruleId": "",
    "ruleTitle": "Lifecycle Hooks",
    "type": "bad",
    "code": "// No initialization or connection tracking\nimport { spacetimedb, table, t, ReducerContext } from 'spacetimedb';\n\nconst GameState = table(\n  { name: 'game_state', public: true },\n  {\n    id: t.string().primaryKey(),\n    status: t.string(),\n  }\n);\n\nconst Player = table(\n  { name: 'player', public: true },\n  {\n    identityId: t.string().primaryKey(),\n    name: t.string(),\n    isOnline: t.bool(), // Never updated!\n  }\n);\n\nspacetimedb.reducer('join_game', { name: t.string() }, (ctx: ReducerContext, { name }) => {\n  // Player online status never gets set properly\n  ctx.db.player.insert({\n    identityId: ctx.sender.toHexString(),\n    name,\n    isOnline: true\n  });\n});",
    "language": "typescript",
    "description": "missing lifecycle hooks"
  },
  {
    "ruleId": "",
    "ruleTitle": "Lifecycle Hooks",
    "type": "good",
    "code": "import { spacetimedb, table, t, ReducerContext } from 'spacetimedb';\n\nconst GameState = table(\n  { name: 'game_state', public: true },\n  {\n    id: t.string().primaryKey(),\n    status: t.string(), // 'waiting' | 'active' | 'finished'\n    createdAt: t.u64(),\n  }\n);\n\nconst Player = table(\n  { name: 'player', public: true },\n  {\n    identityId: t.identity().primaryKey(),\n    name: t.string(),\n    isOnline: t.bool(),\n    lastSeen: t.u64(),\n  }\n);\n\n// Initialize game state when module is first published\nspacetimedb.init((ctx: ReducerContext) => {\n  // Create initial game state if it doesn't exist\n  if (!ctx.db.game_state.id.find('main')) {\n    ctx.db.game_state.insert({\n      id: 'main',\n      status: 'waiting',\n      createdAt: ctx.timestamp\n    });\n  }\n});\n\n// Track when a client connects\nspacetimedb.clientConnected((ctx: ReducerContext) => {\n  const identityId = ctx.sender;\n  const player = ctx.db.player.identityId.find(identityId);\n\n  if (player) {\n    // Mark existing player as online\n    ctx.db.player.identityId.update({\n      ...player,\n      isOnline: true,\n      lastSeen: ctx.timestamp\n    });\n  }\n});\n\n// Track when a client disconnects\nspacetimedb.clientDisconnected((ctx: ReducerContext) => {\n  const identityId = ctx.sender;\n  const player = ctx.db.player.identityId.find(identityId);\n\n  if (player) {\n    ctx.db.player.identityId.update({\n      ...player,\n      isOnline: false,\n      lastSeen: ctx.timestamp\n    });\n  }\n});\n\nspacetimedb.reducer('register_player', { name: t.string() }, (ctx: ReducerContext, { name }) => {\n  const identityId = ctx.sender;\n\n  if (ctx.db.player.identityId.find(identityId)) {\n    throw new Error('Player already registered');\n  }\n\n  ctx.db.player.insert({\n    identityId,\n    name,\n    isOnline: true,\n    lastSeen: ctx.timestamp\n  });\n});",
    "language": "typescript",
    "description": "proper lifecycle management"
  },
  {
    "ruleId": "",
    "ruleTitle": "Single Responsibility Modules",
    "type": "bad",
    "code": "// module.ts - handles users, products, AND orders\nimport { spacetimedb, table, t, ReducerContext, Table } from 'spacetimedb';\n\nconst User = table(\n  { name: 'user', public: true },\n  {\n    id: t.string().primaryKey(),\n    name: t.string(),\n  }\n);\n\nconst Product = table(\n  { name: 'product', public: true },\n  {\n    id: t.string().primaryKey(),\n    name: t.string(),\n    price: t.u64(),\n  }\n);\n\nconst Order = table(\n  { name: 'order', public: true },\n  {\n    id: t.string().primaryKey(),\n    userId: t.string(),\n    productId: t.string(),\n  }\n);\n\n// Too many unrelated reducers in one module\nspacetimedb.reducer('create_user', { name: t.string() }, (ctx: ReducerContext, { name }) => {\n  /* ... */\n});\n\nspacetimedb.reducer('update_product', { id: t.string(), price: t.u64() }, (ctx: ReducerContext, { id, price }) => {\n  /* ... */\n});\n\nspacetimedb.reducer('place_order', { userId: t.string(), productId: t.string() }, (ctx: ReducerContext, { userId, productId }) => {\n  /* ... */\n});",
    "language": "typescript",
    "description": "multiple concerns in one module"
  },
  {
    "ruleId": "",
    "ruleTitle": "Single Responsibility Modules",
    "type": "good",
    "code": "// orders/module.ts\nimport { spacetimedb, table, t, ReducerContext } from 'spacetimedb';\n\nexport const Order = table(\n  { name: 'order', public: true },\n  {\n    id: t.string().primaryKey(),\n    userId: t.string().index(),\n    productId: t.string(),\n    quantity: t.u32(),\n    createdAt: t.u64(),\n  }\n);\n\nfunction generateId(): string {\n  return crypto.randomUUID();\n}\n\nspacetimedb.reducer('place_order', { productId: t.string(), quantity: t.u32() }, (ctx: ReducerContext, { productId, quantity }) => {\n  const userId = ctx.sender.toHexString();\n  ctx.db.order.insert({\n    id: generateId(),\n    userId,\n    productId,\n    quantity,\n    createdAt: ctx.timestamp\n  });\n});",
    "language": "typescript",
    "description": "separate modules per domain"
  },
  {
    "ruleId": "",
    "ruleTitle": "Reducer Hooks with Error Handling",
    "type": "bad",
    "code": "import { useState } from 'react';\nimport { DbConnection } from './generated';\n\nfunction SendMessageButton({ channelId, conn }: { channelId: string; conn: DbConnection }) {\n  const [message, setMessage] = useState('');\n\n  const handleSend = () => {\n    // Fire and forget - no feedback to user\n    conn.reducers.sendMessage(channelId, message);\n    setMessage('');\n  };\n\n  return (\n    <div>\n      <input value={message} onChange={e => setMessage(e.target.value)} />\n      <button onClick={handleSend}>Send</button>\n    </div>\n  );\n}",
    "language": "typescript",
    "description": "no error handling or loading states"
  },
  {
    "ruleId": "",
    "ruleTitle": "Reducer Hooks with Error Handling",
    "type": "good",
    "code": "import { useState, useCallback } from 'react';\nimport { DbConnection } from './generated';\n\n// Custom hook for reducer with loading/error states\nfunction useReducerWithState<T extends any[]>(\n  conn: DbConnection | null,\n  reducerName: keyof DbConnection['reducers']\n): [(...args: T) => Promise<void>, { loading: boolean; error: Error | null }] {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  const call = useCallback(async (...args: T) => {\n    if (!conn) {\n      setError(new Error('Not connected'));\n      return;\n    }\n\n    setLoading(true);\n    setError(null);\n\n    try {\n      await (conn.reducers[reducerName] as (...args: T) => Promise<void>)(...args);\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error(String(err));\n      setError(error);\n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  }, [conn, reducerName]);\n\n  return [call, { loading, error }];\n}\n\n// Message sending with proper feedback\nfunction MessageInput({ channelId, conn }: { channelId: string; conn: DbConnection }) {\n  const [message, setMessage] = useState('');\n  const [sendMessage, { loading, error }] = useReducerWithState<[string, string]>(\n    conn,\n    'sendMessage'\n  );\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n\n    if (!message.trim()) return;\n\n    try {\n      await sendMessage(channelId, message.trim());\n      setMessage(''); // Only clear on success\n    } catch (err) {\n      // Error is already set in hook state\n      console.error('Failed to send message:', err);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        value={message}\n        onChange={e => setMessage(e.target.value)}\n        disabled={loading}\n        placeholder=\"Type a message...\"\n      />\n      <button type=\"submit\" disabled={loading || !message.trim()}>\n        {loading ? 'Sending...' : 'Send'}\n      </button>\n      {error && (\n        <div style={{ color: 'red' }}>\n          Failed to send: {error.message}\n        </div>\n      )}\n    </form>\n  );\n}\n\n// Optimistic updates for instant feedback\nfunction LikeButton({\n  postId,\n  currentLikes,\n  conn\n}: {\n  postId: string;\n  currentLikes: number;\n  conn: DbConnection;\n}) {\n  const [optimisticLikes, setOptimisticLikes] = useState<number | null>(null);\n  const [likePost, { loading, error }] = useReducerWithState<[string]>(\n    conn,\n    'likePost'\n  );\n\n  const handleLike = async () => {\n    // Optimistic update - show new count immediately\n    setOptimisticLikes(currentLikes + 1);\n\n    try {\n      await likePost(postId);\n      // Success - optimistic update will be replaced by real data\n    } catch (err) {\n      // Revert optimistic update on failure\n      setOptimisticLikes(null);\n    }\n  };\n\n  const displayLikes = optimisticLikes ?? currentLikes;\n\n  return (\n    <button onClick={handleLike} disabled={loading}>\n      ❤️ {displayLikes}\n      {error && ' (failed)'}\n    </button>\n  );\n}\n\n// Complex form with multiple reducers\nfunction CreateGameForm({ conn }: { conn: DbConnection }) {\n  const [gameName, setGameName] = useState('');\n  const [maxPlayers, setMaxPlayers] = useState(4);\n\n  const [createGame, createState] = useReducerWithState<[string, number]>(\n    conn,\n    'createGame'\n  );\n  const [joinGame, joinState] = useReducerWithState<[string]>(\n    conn,\n    'joinGame'\n  );\n\n  const handleCreate = async (e: React.FormEvent) => {\n    e.preventDefault();\n\n    try {\n      // Create game and join it\n      await createGame(gameName, maxPlayers);\n      // After game is created, we'd typically get the game ID from state\n      // and then join it\n    } catch (err) {\n      // Error states are handled by individual hooks\n    }\n  };\n\n  const loading = createState.loading || joinState.loading;\n  const error = createState.error || joinState.error;\n\n  return (\n    <form onSubmit={handleCreate}>\n      <input\n        value={gameName}\n        onChange={e => setGameName(e.target.value)}\n        placeholder=\"Game name\"\n        disabled={loading}\n      />\n      <select\n        value={maxPlayers}\n        onChange={e => setMaxPlayers(Number(e.target.value))}\n        disabled={loading}\n      >\n        {[2, 4, 6, 8].map(n => (\n          <option key={n} value={n}>{n} players</option>\n        ))}\n      </select>\n      <button type=\"submit\" disabled={loading || !gameName.trim()}>\n        {loading ? 'Creating...' : 'Create Game'}\n      </button>\n      {error && (\n        <div style={{ color: 'red' }}>\n          {error.message}\n        </div>\n      )}\n    </form>\n  );\n}",
    "language": "typescript",
    "description": "proper hooks with error handling"
  },
  {
    "ruleId": "",
    "ruleTitle": "React Table Hooks",
    "type": "bad",
    "code": "import { useState, useEffect } from 'react';\nimport { DbConnection, Player } from './generated';\n\n// Manually managing state - error-prone and verbose\nfunction PlayerList({ conn }: { conn: DbConnection }) {\n  const [players, setPlayers] = useState<Player[]>([]);\n\n  useEffect(() => {\n    // Manual subscription setup\n    const sub = conn.subscription(['SELECT * FROM player WHERE isOnline = true']);\n\n    // Manual event handling\n    const handleInsert = (player: Player) => {\n      setPlayers(prev => [...prev, player]);\n    };\n\n    const handleUpdate = (oldPlayer: Player, newPlayer: Player) => {\n      setPlayers(prev => prev.map(p =>\n        p.identity.toHexString() === newPlayer.identity.toHexString() ? newPlayer : p\n      ));\n    };\n\n    const handleDelete = (player: Player) => {\n      setPlayers(prev => prev.filter(p =>\n        p.identity.toHexString() !== player.identity.toHexString()\n      ));\n    };\n\n    conn.db.player.onInsert(handleInsert);\n    conn.db.player.onUpdate(handleUpdate);\n    conn.db.player.onDelete(handleDelete);\n\n    return () => {\n      sub?.unsubscribe();\n      conn.db.player.offInsert(handleInsert);\n      conn.db.player.offUpdate(handleUpdate);\n      conn.db.player.offDelete(handleDelete);\n    };\n  }, [conn]);\n\n  return (\n    <ul>\n      {players.map(player => (\n        <li key={player.identity.toHexString()}>{player.name}</li>\n      ))}\n    </ul>\n  );\n}",
    "language": "typescript",
    "description": "manual state management"
  },
  {
    "ruleId": "",
    "ruleTitle": "React Table Hooks",
    "type": "good",
    "code": "import { useMemo } from 'react';\nimport { useTable, where, eq } from 'spacetimedb/react';\nimport { DbConnection, Player, Message } from './generated';\n\n// Simple table hook - all rows\nfunction PlayerList() {\n  // Automatically re-renders when player table changes\n  const { rows: players } = useTable<DbConnection, Player>('player');\n\n  return (\n    <ul>\n      {players.map(player => (\n        <li key={player.identity.toHexString()}>\n          {player.name} - {player.score} points\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// Filtered query hook using where clause\nfunction OnlinePlayerList() {\n  // Only re-renders when online players change\n  const { rows: onlinePlayers } = useTable<DbConnection, Player>(\n    'player',\n    where(eq('isOnline', true))\n  );\n\n  return (\n    <ul>\n      {onlinePlayers.map(player => (\n        <li key={player.identity.toHexString()}>\n          {player.name} - Online\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// Single row lookup\nfunction PlayerProfile({ playerId }: { playerId: string }) {\n  const { rows: players } = useTable<DbConnection, Player>('player');\n\n  // Find the specific player\n  const player = players.find(p => p.identity.toHexString() === playerId);\n\n  if (!player) {\n    return <div>Player not found</div>;\n  }\n\n  return (\n    <div>\n      <h2>{player.name}</h2>\n      <p>Score: {player.score}</p>\n      <p>Status: {player.isOnline ? 'Online' : 'Offline'}</p>\n    </div>\n  );\n}\n\n// Computed/derived data\nfunction GameStats() {\n  const { rows: players } = useTable<DbConnection, Player>('player');\n\n  // Derived calculations are memoized\n  const stats = useMemo(() => ({\n    totalPlayers: players.length,\n    onlinePlayers: players.filter(p => p.isOnline).length,\n    averageScore: players.length > 0\n      ? players.reduce((sum, p) => sum + Number(p.score), 0) / players.length\n      : 0,\n    topPlayer: players.reduce((top, p) =>\n      Number(p.score) > (top ? Number(top.score) : 0) ? p : top,\n      null as Player | null\n    )\n  }), [players]);\n\n  return (\n    <div>\n      <p>Total Players: {stats.totalPlayers}</p>\n      <p>Online: {stats.onlinePlayers}</p>\n      <p>Average Score: {stats.averageScore.toFixed(0)}</p>\n      {stats.topPlayer && (\n        <p>Top Player: {stats.topPlayer.name} ({stats.topPlayer.score.toString()})</p>\n      )}\n    </div>\n  );\n}\n\n// Multiple tables with relationships\nfunction MessageWithAuthor({ messageId }: { messageId: string }) {\n  const { rows: messages } = useTable<DbConnection, Message>('message');\n  const { rows: players } = useTable<DbConnection, Player>('player');\n\n  const message = messages.find(m => m.id === messageId);\n  const author = message\n    ? players.find(p => p.identity.toHexString() === message.authorId.toHexString())\n    : null;\n\n  if (!message || !author) {\n    return <div>Loading...</div>;\n  }\n\n  return (\n    <div>\n      <strong>{author.name}</strong>: {message.content}\n    </div>\n  );\n}",
    "language": "typescript",
    "description": "using React hooks"
  },
  {
    "ruleId": "",
    "ruleTitle": "Atomic Reducers",
    "type": "bad",
    "code": "import { spacetimedb, t, ReducerContext } from 'spacetimedb';\n\nspacetimedb.reducer(\n  'process_game_turn',\n  { playerId: t.string(), action: t.string() },\n  (ctx: ReducerContext, { playerId, action }) => {\n    // This reducer does too many things - if it fails partway through,\n    // it's hard to know what state we're in\n\n    // Step 1: Update player position\n    const player = ctx.db.player.id.find(playerId);\n    ctx.db.player.id.update({ ...player, position: calculateNewPosition(action) });\n\n    // Step 2: Check for collisions with all other players\n    const allPlayers = ctx.db.player.iter();\n    for (const other of allPlayers) {\n      if (checkCollision(player, other)) {\n        // Step 3: Apply damage\n        ctx.db.player.id.update({ ...other, health: other.health - 10 });\n        // Step 4: Create combat log\n        ctx.db.combat_log.insert({ /* ... */ });\n        // Step 5: Update leaderboard\n        ctx.db.leaderboard.id.update({ /* ... */ });\n        // Step 6: Award achievements\n        checkAndAwardAchievements(ctx, playerId);\n      }\n    }\n\n    // Step 7: Advance game state\n    advanceGameState(ctx);\n  }\n);",
    "language": "typescript",
    "description": "non-atomic reducer doing too much"
  },
  {
    "ruleId": "",
    "ruleTitle": "Atomic Reducers",
    "type": "good",
    "code": "import { spacetimedb, t, ReducerContext } from 'spacetimedb';\n\nfunction generateId(): string {\n  return crypto.randomUUID();\n}\n\n// Each reducer does ONE thing well\n\nspacetimedb.reducer(\n  'move_player',\n  { direction: t.string() },\n  (ctx: ReducerContext, { direction }) => {\n    const playerId = ctx.sender;\n    const player = ctx.db.player.identity.find(playerId);\n\n    if (!player) {\n      throw new Error('Player not found');\n    }\n\n    const newPosition = calculateNewPosition(player.position, direction);\n\n    if (!isValidPosition(newPosition)) {\n      throw new Error('Invalid move');\n    }\n\n    ctx.db.player.identity.update({\n      ...player,\n      position: newPosition,\n      lastMoveAt: ctx.timestamp\n    });\n  }\n);\n\nspacetimedb.reducer(\n  'attack_player',\n  { targetId: t.identity(), damage: t.u32() },\n  (ctx: ReducerContext, { targetId, damage }) => {\n    const attackerId = ctx.sender;\n    const target = ctx.db.player.identity.find(targetId);\n\n    if (!target) {\n      throw new Error('Target not found');\n    }\n\n    const newHealth = Math.max(0, target.health - damage);\n\n    ctx.db.player.identity.update({\n      ...target,\n      health: newHealth\n    });\n\n    ctx.db.combat_log.insert({\n      id: generateId(),\n      attackerId,\n      targetId,\n      damage,\n      timestamp: ctx.timestamp\n    });\n  }\n);\n\nspacetimedb.reducer(\n  'claim_achievement',\n  { achievementId: t.string() },\n  (ctx: ReducerContext, { achievementId }) => {\n    const playerId = ctx.sender;\n    const player = ctx.db.player.identity.find(playerId);\n\n    if (!player) {\n      throw new Error('Player not found');\n    }\n\n    // Verify achievement requirements\n    if (!checkAchievementRequirements(ctx, playerId, achievementId)) {\n      throw new Error('Achievement requirements not met');\n    }\n\n    // Check if already claimed\n    const existing = ctx.db.player_achievement.playerId.filter(playerId)\n      .find(a => a.achievementId === achievementId);\n\n    if (existing) {\n      throw new Error('Achievement already claimed');\n    }\n\n    ctx.db.player_achievement.insert({\n      playerId,\n      achievementId,\n      claimedAt: ctx.timestamp\n    });\n  }\n);",
    "language": "typescript",
    "description": "atomic, focused reducers"
  },
  {
    "ruleId": "",
    "ruleTitle": "Authorization Checks",
    "type": "bad",
    "code": "import { spacetimedb, t, ReducerContext } from 'spacetimedb';\n\nspacetimedb.reducer(\n  'delete_message',\n  { messageId: t.string() },\n  (ctx: ReducerContext, { messageId }) => {\n    // Anyone can delete any message!\n    ctx.db.message.id.delete(messageId);\n  }\n);\n\nspacetimedb.reducer(\n  'update_user_profile',\n  { userId: t.identity(), newName: t.string() },\n  (ctx: ReducerContext, { userId, newName }) => {\n    // Anyone can update any user's profile!\n    const user = ctx.db.user.identity.find(userId);\n    ctx.db.user.identity.update({ ...user, name: newName });\n  }\n);\n\nspacetimedb.reducer(\n  'ban_user',\n  { userId: t.identity() },\n  (ctx: ReducerContext, { userId }) => {\n    // Anyone can ban anyone!\n    const user = ctx.db.user.identity.find(userId);\n    ctx.db.user.identity.update({ ...user, isBanned: true });\n  }\n);",
    "language": "typescript",
    "description": "no authorization checks"
  },
  {
    "ruleId": "",
    "ruleTitle": "Authorization Checks",
    "type": "good",
    "code": "import { spacetimedb, table, t, ReducerContext } from 'spacetimedb';\n\nconst Admin = table(\n  { name: 'admin', public: true },\n  {\n    identity: t.identity().primaryKey(),\n    role: t.string(), // 'super_admin' | 'moderator'\n  }\n);\n\nfunction generateId(): string {\n  return crypto.randomUUID();\n}\n\nspacetimedb.reducer(\n  'delete_message',\n  { messageId: t.string() },\n  (ctx: ReducerContext, { messageId }) => {\n    const callerId = ctx.sender;\n\n    const message = ctx.db.message.id.find(messageId);\n    if (!message) {\n      throw new Error('Message not found');\n    }\n\n    // Check if caller is the message author OR an admin\n    const isAuthor = message.authorId.toHexString() === callerId.toHexString();\n    const isAdmin = ctx.db.admin.identity.find(callerId) !== undefined;\n\n    if (!isAuthor && !isAdmin) {\n      throw new Error('Not authorized to delete this message');\n    }\n\n    ctx.db.message.id.delete(messageId);\n\n    // Log admin actions for audit\n    if (isAdmin && !isAuthor) {\n      ctx.db.audit_log.insert({\n        id: generateId(),\n        adminId: callerId,\n        action: 'delete_message',\n        targetId: messageId,\n        timestamp: ctx.timestamp\n      });\n    }\n  }\n);\n\nspacetimedb.reducer(\n  'update_user_profile',\n  { newName: t.string() },\n  (ctx: ReducerContext, { newName }) => {\n    // Users can only update their OWN profile\n    const userId = ctx.sender;\n\n    const user = ctx.db.user.identity.find(userId);\n    if (!user) {\n      throw new Error('User not found');\n    }\n\n    if (!newName || newName.trim().length === 0) {\n      throw new Error('Name cannot be empty');\n    }\n\n    ctx.db.user.identity.update({\n      ...user,\n      name: newName.trim(),\n      updatedAt: ctx.timestamp\n    });\n  }\n);\n\nspacetimedb.reducer(\n  'ban_user',\n  { userId: t.identity(), reason: t.string() },\n  (ctx: ReducerContext, { userId, reason }) => {\n    const adminId = ctx.sender;\n\n    // Verify caller is an admin\n    const admin = ctx.db.admin.identity.find(adminId);\n    if (!admin) {\n      throw new Error('Only admins can ban users');\n    }\n\n    // Verify target exists\n    const targetUser = ctx.db.user.identity.find(userId);\n    if (!targetUser) {\n      throw new Error('User not found');\n    }\n\n    // Prevent banning other admins (unless super_admin)\n    const targetAdmin = ctx.db.admin.identity.find(userId);\n    if (targetAdmin && admin.role !== 'super_admin') {\n      throw new Error('Only super admins can ban other admins');\n    }\n\n    // Prevent self-ban\n    if (adminId.toHexString() === userId.toHexString()) {\n      throw new Error('Cannot ban yourself');\n    }\n\n    ctx.db.user.identity.update({\n      ...targetUser,\n      isBanned: true,\n      bannedAt: ctx.timestamp,\n      bannedBy: adminId,\n      banReason: reason\n    });\n\n    ctx.db.audit_log.insert({\n      id: generateId(),\n      adminId,\n      action: 'ban_user',\n      targetId: userId.toHexString(),\n      details: reason,\n      timestamp: ctx.timestamp\n    });\n  }\n);",
    "language": "typescript",
    "description": "proper authorization"
  },
  {
    "ruleId": "",
    "ruleTitle": "Input Validation at Reducer Entry",
    "type": "bad",
    "code": "import { spacetimedb, t, ReducerContext } from 'spacetimedb';\n\nspacetimedb.reducer(\n  'create_product',\n  { name: t.string(), price: t.u64(), stock: t.u32() },\n  (ctx: ReducerContext, { name, price, stock }) => {\n    // No validation - accepts any input!\n    ctx.db.product.insert({\n      id: generateId(),\n      name,\n      price,\n      stock,\n      createdBy: ctx.sender\n    });\n  }\n);\n\nspacetimedb.reducer(\n  'transfer_funds',\n  { toUserId: t.identity(), amount: t.u64() },\n  (ctx: ReducerContext, { toUserId, amount }) => {\n    const fromUser = ctx.db.user.identity.find(ctx.sender);\n    const toUser = ctx.db.user.identity.find(toUserId);\n\n    // No validation - could transfer negative amounts or overdraw!\n    ctx.db.user.identity.update({ ...fromUser, balance: fromUser.balance - amount });\n    ctx.db.user.identity.update({ ...toUser, balance: toUser.balance + amount });\n  }\n);",
    "language": "typescript",
    "description": "no input validation"
  },
  {
    "ruleId": "",
    "ruleTitle": "Input Validation at Reducer Entry",
    "type": "good",
    "code": "import { spacetimedb, t, ReducerContext } from 'spacetimedb';\n\nfunction generateId(): string {\n  return crypto.randomUUID();\n}\n\nspacetimedb.reducer(\n  'create_product',\n  { name: t.string(), price: t.u64(), stock: t.u32() },\n  (ctx: ReducerContext, { name, price, stock }) => {\n    // Validate all inputs first\n    if (!name || name.trim().length === 0) {\n      throw new Error('Product name is required');\n    }\n\n    if (name.length > 100) {\n      throw new Error('Product name must be 100 characters or less');\n    }\n\n    if (price <= 0n) {\n      throw new Error('Price must be positive');\n    }\n\n    // Check for duplicate names\n    const existing = [...ctx.db.product.iter()].find(p => p.name === name.trim());\n    if (existing) {\n      throw new Error('Product with this name already exists');\n    }\n\n    // All validation passed - safe to insert\n    ctx.db.product.insert({\n      id: generateId(),\n      name: name.trim(),\n      price,\n      stock,\n      createdBy: ctx.sender,\n      createdAt: ctx.timestamp\n    });\n  }\n);\n\nspacetimedb.reducer(\n  'transfer_funds',\n  { toUserId: t.identity(), amount: t.u64() },\n  (ctx: ReducerContext, { toUserId, amount }) => {\n    // Validate amount\n    if (amount <= 0n) {\n      throw new Error('Amount must be positive');\n    }\n\n    // Validate recipient exists\n    const toUser = ctx.db.user.identity.find(toUserId);\n    if (!toUser) {\n      throw new Error('Recipient not found');\n    }\n\n    // Validate sender exists and has sufficient balance\n    const fromUser = ctx.db.user.identity.find(ctx.sender);\n    if (!fromUser) {\n      throw new Error('Sender not found');\n    }\n\n    // Prevent self-transfer\n    if (ctx.sender.toHexString() === toUserId.toHexString()) {\n      throw new Error('Cannot transfer to yourself');\n    }\n\n    // Check sufficient balance\n    if (fromUser.balance < amount) {\n      throw new Error('Insufficient balance');\n    }\n\n    // All validation passed - safe to transfer\n    ctx.db.user.identity.update({\n      ...fromUser,\n      balance: fromUser.balance - amount\n    });\n\n    ctx.db.user.identity.update({\n      ...toUser,\n      balance: toUser.balance + amount\n    });\n\n    // Log the transaction\n    ctx.db.transaction.insert({\n      id: generateId(),\n      fromUserId: ctx.sender,\n      toUserId,\n      amount,\n      timestamp: ctx.timestamp\n    });\n  }\n);",
    "language": "typescript",
    "description": "comprehensive input validation"
  },
  {
    "ruleId": "",
    "ruleTitle": "Selective Subscriptions",
    "type": "bad",
    "code": "// Client subscribes to ALL data - wasteful!\nimport { DbConnection } from './generated';\n\nconst conn = DbConnection.builder()\n  .withUri('ws://localhost:3000')\n  .withModuleName('game-module')\n  .onConnect((ctx, identity, token) => {\n    // Downloads ALL messages ever sent\n    conn.subscription(['SELECT * FROM message']);\n\n    // Downloads ALL players, not just ones in current game\n    conn.subscription(['SELECT * FROM player']);\n\n    // Downloads entire inventory for ALL users\n    conn.subscription(['SELECT * FROM inventory']);\n  })\n  .build();",
    "language": "typescript",
    "description": "subscribing to entire tables"
  },
  {
    "ruleId": "",
    "ruleTitle": "Selective Subscriptions",
    "type": "good",
    "code": "// React component with selective subscription\nimport { useEffect, useState } from 'react';\nimport { useTable, where, eq } from 'spacetimedb/react';\nimport { DbConnection, Message } from './generated';\n\nfunction ChatRoom({ channelId, conn }: { channelId: string; conn: DbConnection }) {\n  const [subscription, setSubscription] = useState<any>(null);\n\n  useEffect(() => {\n    // Subscribe when component mounts with specific channel\n    const sub = conn.subscription([\n      'SELECT * FROM message WHERE channelId = ?',\n      channelId\n    ]);\n    setSubscription(sub);\n\n    return () => {\n      // Unsubscribe when component unmounts or channelId changes\n      sub?.unsubscribe();\n    };\n  }, [channelId, conn]);\n\n  // Use React hooks with filtering\n  const { rows: messages } = useTable<DbConnection, Message>(\n    'message',\n    where(eq('channelId', channelId))\n  );\n\n  return (\n    <div>\n      {messages.map(msg => (\n        <MessageComponent key={msg.id} message={msg} />\n      ))}\n    </div>\n  );\n}",
    "language": "typescript",
    "description": "selective subscriptions with filters"
  },
  {
    "ruleId": "",
    "ruleTitle": "Debounce Rapid Updates",
    "type": "bad",
    "code": "import { useTable } from 'spacetimedb/react';\nimport { DbConnection, PlayerCursor } from './generated';\n\nfunction CursorOverlay() {\n  const { rows: cursors } = useTable<DbConnection, PlayerCursor>('player_cursor');\n\n  // Re-renders on EVERY cursor movement - could be 60+ times per second per player!\n  return (\n    <div>\n      {cursors.map(cursor => (\n        <div\n          key={cursor.playerId.toHexString()}\n          style={{\n            position: 'absolute',\n            left: cursor.x,\n            top: cursor.y\n          }}\n        >\n          {cursor.playerName}\n        </div>\n      ))}\n    </div>\n  );\n}\n\n// Sending every mouse move - floods the server\nfunction Canvas({ conn }: { conn: DbConnection }) {\n  const handleMouseMove = (e: React.MouseEvent) => {\n    conn.reducers.updateCursor(e.clientX, e.clientY);\n  };\n\n  return <canvas onMouseMove={handleMouseMove} />;\n}",
    "language": "typescript",
    "description": "updating on every change"
  },
  {
    "ruleId": "",
    "ruleTitle": "Debounce Rapid Updates",
    "type": "good",
    "code": "import { useMemo, useRef, useEffect, useCallback, useState } from 'react';\nimport { useTable } from 'spacetimedb/react';\nimport { DbConnection, PlayerCursor, TypingIndicator } from './generated';\n\n// Throttle hook for limiting update frequency\nfunction useThrottle<T>(value: T, interval: number): T {\n  const [throttledValue, setThrottledValue] = useState(value);\n  const lastUpdated = useRef(Date.now());\n\n  useEffect(() => {\n    const now = Date.now();\n    if (now - lastUpdated.current >= interval) {\n      lastUpdated.current = now;\n      setThrottledValue(value);\n    } else {\n      const timerId = setTimeout(() => {\n        lastUpdated.current = Date.now();\n        setThrottledValue(value);\n      }, interval - (now - lastUpdated.current));\n\n      return () => clearTimeout(timerId);\n    }\n  }, [value, interval]);\n\n  return throttledValue;\n}\n\n// Throttled cursor overlay - updates at most 30fps\nfunction CursorOverlay() {\n  const { rows: rawCursors } = useTable<DbConnection, PlayerCursor>('player_cursor');\n\n  // Throttle to 30fps for smooth but performant rendering\n  const cursors = useThrottle(rawCursors, 33);\n\n  // Use CSS transforms for GPU acceleration\n  return (\n    <div>\n      {cursors.map(cursor => (\n        <div\n          key={cursor.playerId.toHexString()}\n          style={{\n            position: 'absolute',\n            transform: `translate(${cursor.x}px, ${cursor.y}px)`,\n            willChange: 'transform'\n          }}\n        >\n          {cursor.playerName}\n        </div>\n      ))}\n    </div>\n  );\n}\n\n// Throttled mouse position sending\nfunction Canvas({ conn }: { conn: DbConnection }) {\n  const lastSent = useRef(0);\n  const pendingPosition = useRef<{ x: number; y: number } | null>(null);\n\n  const sendPosition = useCallback(() => {\n    if (pendingPosition.current) {\n      conn.reducers.updateCursor(\n        pendingPosition.current.x,\n        pendingPosition.current.y\n      );\n      pendingPosition.current = null;\n    }\n  }, [conn]);\n\n  const handleMouseMove = useCallback((e: React.MouseEvent) => {\n    pendingPosition.current = { x: e.clientX, y: e.clientY };\n\n    const now = Date.now();\n    if (now - lastSent.current >= 50) { // Max 20 updates per second\n      lastSent.current = now;\n      sendPosition();\n    }\n  }, [sendPosition]);\n\n  // Send final position on mouse stop\n  useEffect(() => {\n    const interval = setInterval(() => {\n      if (pendingPosition.current) {\n        sendPosition();\n      }\n    }, 100);\n\n    return () => clearInterval(interval);\n  }, [sendPosition]);\n\n  return <canvas onMouseMove={handleMouseMove} />;\n}\n\n// Debounced typing indicator\nfunction TypingIndicatorDisplay({ channelId }: { channelId: string }) {\n  const { rows: typingUsers } = useTable<DbConnection, TypingIndicator>('typing_indicator');\n\n  // Filter to current channel and recent activity\n  const activeTyping = typingUsers.filter(\n    u => u.channelId === channelId && Number(u.lastTypedAt) > Date.now() - 3000\n  );\n\n  // Debounce the display to avoid flicker\n  const [debouncedTyping, setDebouncedTyping] = useState(activeTyping);\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setDebouncedTyping(activeTyping);\n    }, 300);\n\n    return () => clearTimeout(timer);\n  }, [activeTyping]);\n\n  if (debouncedTyping.length === 0) return null;\n\n  const names = debouncedTyping.map(u => u.userName).join(', ');\n\n  return (\n    <div className=\"typing-indicator\">\n      {names} {debouncedTyping.length === 1 ? 'is' : 'are'} typing...\n    </div>\n  );\n}\n\n// Debounced input for sending typing indicator\nfunction MessageInput({ channelId, conn }: { channelId: string; conn: DbConnection }) {\n  const [message, setMessage] = useState('');\n  const typingTimeout = useRef<NodeJS.Timeout | null>(null);\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setMessage(e.target.value);\n\n    // Debounce typing indicator updates\n    if (typingTimeout.current) {\n      clearTimeout(typingTimeout.current);\n    }\n\n    // Send typing indicator\n    conn.reducers.setTyping(channelId, true);\n\n    // Clear typing after 2 seconds of no input\n    typingTimeout.current = setTimeout(() => {\n      conn.reducers.setTyping(channelId, false);\n    }, 2000);\n  };\n\n  return (\n    <input\n      value={message}\n      onChange={handleChange}\n      placeholder=\"Type a message...\"\n    />\n  );\n}",
    "language": "typescript",
    "description": "debounced/throttled updates"
  },
  {
    "ruleId": "",
    "ruleTitle": "Index Frequently Queried Columns",
    "type": "bad",
    "code": "import { spacetimedb, table, t } from 'spacetimedb';\n\nconst Message = table(\n  { name: 'message', public: true },\n  {\n    id: t.string().primaryKey(),\n\n    // These are frequently queried but not indexed!\n    senderId: t.identity(),\n    recipientId: t.identity(),\n    channelId: t.string(),\n\n    content: t.string(),\n    timestamp: t.u64(),\n  }\n);\n\n// Client subscribes to messages by channel - slow without index!\n// subscription: SELECT * FROM message WHERE channelId = 'general'",
    "language": "typescript",
    "description": "missing indexes on frequently queried columns"
  },
  {
    "ruleId": "",
    "ruleTitle": "Index Frequently Queried Columns",
    "type": "good",
    "code": "// Client can now efficiently subscribe to specific data\nimport { DbConnection } from './generated';\n\nconst conn = DbConnection.builder()\n  .withUri('ws://localhost:3000')\n  .withModuleName('my-module')\n  .onConnect((ctx, identity, token) => {\n    // Fast - uses channelId index\n    conn.subscription(['SELECT * FROM message WHERE channelId = ?', channelId]);\n\n    // Fast - uses isOnline index\n    conn.subscription(['SELECT * FROM player WHERE isOnline = true']);\n\n    // Fast - uses score index for leaderboard\n    conn.subscription(['SELECT * FROM player ORDER BY score DESC LIMIT 100']);\n  })\n  .build();",
    "language": "typescript",
    "description": "indexes on query columns"
  },
  {
    "ruleId": "",
    "ruleTitle": "Primary Key Strategies",
    "type": "bad",
    "code": "import { spacetimedb, table, t } from 'spacetimedb';\n\n// Using mutable data as primary key\nconst Player = table(\n  { name: 'player', public: true },\n  {\n    username: t.string().primaryKey(), // Bad: username might change!\n    score: t.u64(),\n  }\n);\n\n// No primary key at all\nconst Message = table(\n  { name: 'message', public: true },\n  {\n    content: t.string(),\n    senderId: t.string(),\n    timestamp: t.u64(),\n    // Missing .primaryKey() - compilation error\n  }\n);\n\n// Using auto-increment when identity would be better\nconst UserProfile = table(\n  { name: 'user_profile', public: true },\n  {\n    id: t.u64().primaryKey().autoInc(), // Bad: loses relationship to identity\n    displayName: t.string(),\n  }\n);",
    "language": "typescript",
    "description": "poor primary key choices"
  },
  {
    "ruleId": "",
    "ruleTitle": "Primary Key Strategies",
    "type": "good",
    "code": "// Helper for generating UUIDs\nfunction generateId(): string {\n  return crypto.randomUUID();\n}\n\nspacetimedb.reducer(\n  'send_message',\n  { recipientId: t.identity(), content: t.string() },\n  (ctx: ReducerContext, { recipientId, content }) => {\n    ctx.db.message.insert({\n      id: generateId(),\n      senderId: ctx.sender,\n      recipientId,\n      content,\n      timestamp: ctx.timestamp\n    });\n  }\n);",
    "language": "typescript",
    "description": "appropriate primary key strategies"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Generated Types",
    "type": "bad",
    "code": "// Manually defined types - can drift from server schema!\n\ninterface Player {\n  id: string; // Wrong! Server uses identity\n  name: string;\n  score: number;\n  isOnline: boolean;\n  // Missing lastSeen field that server has!\n}\n\ninterface Message {\n  id: string;\n  authorId: string;\n  content: string;\n  timestamp: number; // Wrong! Server uses bigint (u64)\n}\n\nfunction PlayerCard({ player }: { player: Player }) {\n  // Type mismatch - runtime errors waiting to happen\n  return <div>{player.name}: {player.score}</div>;\n}",
    "language": "typescript",
    "description": "manually defined types"
  },
  {
    "ruleId": "",
    "ruleTitle": "Use Generated Types",
    "type": "good",
    "code": "// Generated types example (src/generated/index.ts)\n// DO NOT EDIT - Auto-generated by SpacetimeDB CLI\n\nexport interface Player {\n  identity: Identity;\n  name: string;\n  score: bigint;\n  isOnline: boolean;\n  lastSeen: bigint;\n  createdAt: bigint;\n}\n\nexport interface Message {\n  id: string;\n  channelId: string;\n  authorId: Identity;\n  content: string;\n  timestamp: bigint;\n}\n\nexport interface GameState {\n  id: string;\n  status: string; // 'waiting' | 'active' | 'finished'\n  currentRound: number;\n  startedAt: bigint | null;\n}\n\n// DbConnection provides typed access to tables and reducers\nexport interface DbConnection {\n  db: {\n    player: TableHandle<Player>;\n    message: TableHandle<Message>;\n    gameState: TableHandle<GameState>;\n  };\n  reducers: {\n    sendMessage: (channelId: string, content: string) => Promise<void>;\n    createGame: (name: string, maxPlayers: number) => Promise<void>;\n    joinGame: (gameId: string) => Promise<void>;\n  };\n  subscription: (query: [string, ...any[]]) => Subscription;\n}",
    "language": "typescript",
    "description": "using generated types"
  }
]